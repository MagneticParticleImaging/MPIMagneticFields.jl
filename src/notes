

#==

using Unitful, PyPlot, LinearAlgebra
gradient = 5.0u"T/m"
field = [upreferred.([0.0u"T", z*gradient, y*gradient]) for x=-20u"mm":0.5u"mm":20u"mm", y=-20u"mm":0.5u"mm":20u"mm", z=-20u"mm":0.5u"mm":20u"mm"]
imshow(ustrip.(u"T", [norm(field[x, y, z]) for x=1:81, y=1, z=1:81]))

https://juliageometry.github.io/GeometryBasics.jl/stable/

Interpolator und eventuell alte Werte cachen

ReceiveCoil hat <: AbstractField

AbstractEuclideanSpace



GradientField kann eine Funktion definieren, um die Rotation (oder Translation) abzubilden


Dimensionen angeben (1, 2, 3), Vektorfeld zusätzliche Dimensionen -> Rotation wird über Rotation der Vektoren beschrieben

mutable struct RegularGridPositions{T} <: GridPositions where {T<:Unitful.Length}
  shape::Vector{Int}
  fov::Vector{T}
  center::Vector{T}
  sign::Vector{Int}
end

https://github.com/JuliaArrays/StaticArrays.jl
https://juliaarrays.github.io/ArraysOfArrays.jl/stable/#section_ArrayOfSimilarArrays
https://github.com/JuliaArrays/AxisArrays.jl
https://github.com/JuliaArrays/HybridArrays.jl
https://juliaarrays.github.io/SpatioTemporalTraits.jl/stable/
https://github.com/JuliaArrays/RangeArrays.jl

https://docs.julialang.org/en/v1/manual/interfaces/

==#
